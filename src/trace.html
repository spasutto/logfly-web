<!DOCTYPE html>
<html>
<head>

  <title>Trace GPS de vol</title>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!--<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>-->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
    <script src='lib/Leaflet.fullscreen.js'></script>
    <link href='lib/leaflet.fullscreen.css' rel='stylesheet' />
    <script src='lib/leaflet.hotline.js'></script>
    <script src="lib/leaflet.rotatedMarker.js"></script>
    <script src="carto.js"></script>
    <script src="graph.js"></script>
    <script src="anatrace.js"></script>
    <script src="lib/igc-xc-score.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
    <script src="lib/igc2kmz.min.js"></script>

<style>
  body {
    padding: 0;
    margin: 0;
  }
  html, body {
    height: 100%;
    width: 100%;
    font-family: sans-serif;
  }
  p {
    margin: 0;
  }
  #formcont {
    position:fixed;
    left:0;top:0;right:0;bottom:0;
    background-color:white;
    display: none;
  }
  #map {
    position: fixed;
    top: 0;
    bottom: 100px;
    left: 0;
    right: 0;
    overflow: hidden;
  }
  .vz {
    position:absolute;
    right:0;
    top:0;
    bottom:100px;
    width:10px;
    z-index : 20;
  }
  #graph {
    position:fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 100px;
  }
  .gras {
    font-weight: bolder;
  }
  .centre {
    text-align: center;
  }
  .souligne {
    text-decoration: underline;
  }
  .clickable {
    cursor: pointer;
  }
  #iinfos {
    display: none;
    margin : 5px;
    font-weight: bolder;
    font-size : 15pt;
  }
  #popupPolaire {
    display: none;
    position: absolute;
    top: 10px;
    left: 10px;
    border: solid 1px #afafaf;
    background-color: #dfdfdf;
    border-radius: 15px;
    padding: 10px;
  }
  #btnClose {
    position: absolute;
    top: 0;
    right: 0;
    z-index: 20;
    margin: 10px;
    padding: 0px;
    width: 22px;
    height: 20px;
    cursor: pointer;
    border: solid 1px black;
    background-color: #efefef;
    border-radius: 5px;
    text-align: center;
    vertical-align: middle;
    padding-top: 2px;
  }
  #ctinfos {
    max-width: 150px;
  }
  #ctinfos a {
    text-decoration: none;
    background: transparent;
  }
  #ctinfos a:hover {
    background: #447adb;
  }
  #dispmodes>#dispmodes_closed {
    display:none;
  }
  #dispmodes.replie>#dispmodes_closed {
    display:initial;
  }
  #dispmodes>#dispmodes_open {
    display:initial;
  }
  #dispmodes.replie>#dispmodes_open {
    display:none;
  }
  #dispmodes_closed {
    font-weight: bolder;
    font-size: 15pt;
  }
  #dispmodes_closed p {
    width: 30px;
  }
  #loading {
    position: absolute;
    top: 0px;bottom: 0px;right: 0px;left: 0px;
    border: solid 1px #afafaf;
    background-color: #dfdfdf;
    padding: 10px;
    z-index:10;
  }
</style>

</head>
<body>
<div id="loading">
  Chargement...
</div>

<div id="mapcont">
  <div id="map"></div>
  <div id="vz" class="vz"></div>
  <div id="graph"></div>
</div>

<div id="formcont">
<h1>Calcul de vol</h1>
<label for="file-selector">Sélectionnez un fichier IGC : </label>
<input type="file" id="file-selector" accept=".igc" multiple><HR>
<label for="formigc">Ou placez directement le contenu du fichier IGC : </label>
<form id="formigc" method="post" onsubmit="loadIGC(undefined, true);return false;">
<div style="max-width: 640px">
  <textarea type="text" id="igccont" style="width:100%;height:80px"></textarea><BR>
  <input type="submit" id="frmsub" style="display:none;float: right;" value="afficher">
</div>
</form>
</div>

<div id="dispmodes" class="replie">
  <div id="dispmodes_closed">
    <p class="clickable gras centre" onclick="dispmodes.classList.toggle('replie')">+</p>
  </div>
  <div id="dispmodes_open">
    <p class="clickable gras centre souligne" onclick="dispmodes.classList.toggle('replie')">Couleur trace :</p>
    <input type="radio" id="dmVz" name="dispmodes" value="vz" onclick="window.dispmode=this.value;redrawFlight();" checked><label for="dmVz">vz</label><BR>
    <input type="radio" id="dmVx" name="dispmodes" value="vx" onclick="window.dispmode=this.value;redrawFlight();"><label for="dmVx">vx</label><BR>
    <input type="radio" id="dmGR" name="dispmodes" value="GR" onclick="window.dispmode=this.value;redrawFlight();"><label for="dmGR">finesse</label><BR>
    <input type="radio" id="dmAlt" name="dispmodes" value="alt" onclick="window.dispmode=this.value;redrawFlight();"><label for="dmAlt">altitude</label><BR>
    <input type="radio" id="dmAltSol" name="dispmodes" value="altsol" onclick="window.dispmode=this.value;redrawFlight();"><label for="dmAltSol">altitude sol</label><BR>
    <input type="radio" id="dmNone" name="dispmodes" value="none" onclick="window.dispmode=this.value;redrawFlight();"><label for="dmNone">aucune</label>
    <p class="clickable gras centre souligne" onclick="dispmodes.classList.toggle('replie')">Mode altitude :</p>
    <input type="radio" id="dmGpsAlt" name="dispmodesalt" value="gps" onclick="redrawAltData(this.value);" checked><label for="dmGpsAlt">GPS</label><BR>
    <input type="radio" id="dmBaroAlt" name="dispmodesalt" value="baro" onclick="redrawAltData(this.value);"><label for="dmBaroAlt">Barométrique</label><BR>
  </div>
</div>

<div id="popupPolaire">
  <div id="btnClose" title="fermer le graph">X</div>
  <div id="graphPolaire"></div>
</div>

<script>
var tiles = [], tilepaths = [], finesse = 8, dx=0, dy=0, ddx=0, ddy=0, squareside=100;
const tileopacity = 0.5;

  const fileSelector = document.getElementById('file-selector');
  fileSelector.addEventListener('change', (event) => {
    const fileList = event.target.files;
    let filecount = fileList.length;
    let igccont = '';
    [...fileList].forEach(file => {
        const reader = new FileReader();
        reader.addEventListener('load', (event) => {
          igccont += (reader.result + '\n');
          document.getElementById('igccont').value = igccont;
          filecount--;
          document.getElementById('formcont').style.display = 'none';
          if (filecount <= 0) loadIGC(igccont, true);
        });
        reader.readAsText(file);
    });
    event.target.value=null;
  });
  

  Element.prototype.setGradient = function( from, to, horizontal ){
    this.style.background = 'linear-gradient(to '+(horizontal ? 'left' : 'top')+', '+from+', '+to+' 100%)';
  }
  var mapelem = document.getElementById('map');
  var vzelem = document.getElementById('vz');
  var maxvz = 10;
  //http://192.168.1.16/web/logfly-web/src/trace.php?igc=http%3A%2F%2F192.168.1.16%2Fweb%2Flogfly-web%2Fsrc%2FTracklogs%2F392.igc&finfo=http%3A%2F%2F192.168.1.16%2Fweb%2Flogfly-web%2Fsrc%2FTracklogs%2F392.json
  var url = new URL(window.location.href);

  function isTouchDevice() {
    return (('ontouchstart' in window) ||
      (navigator.maxTouchPoints > 0) ||
      (navigator.msMaxTouchPoints > 0));
  }
  function componentToHex(c) {
    var hex = Math.round(c).toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }
  function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
  }
  function getParameter(param, clean) {
    let val = url.searchParams.get(param);
    if (val && clean)
      val = val.trim().toLowerCase();
    return val;
  }

  var istouch = isTouchDevice();
  var igc = getParameter("igc");
  var tzoffset = parseInt(getParameter("tzoffset", true));
  tzoffset = typeof tzoffset === 'number' && !isNaN(tzoffset) ? tzoffset : null;
  var launchtime = parseInt(getParameter("start", true));
  launchtime = !!launchtime && typeof launchtime === 'number' && !isNaN(launchtime) ? new Date(launchtime*1000) : null;
  var finfo = getParameter("finfo");
  var disablescroll = getParameter("disablescroll", true);disablescroll = disablescroll == "true" || disablescroll == "1";
  var clegeoportail = getParameter("clegeoportail");
  var cletimezonedb = getParameter("cletimezonedb") || '';
  var elevationservice = getParameter("elevationservice") || 'elevation/getElevation.php';

  var graph = new GraphGPX(document.getElementById("graph"), {elevationservice:elevationservice, disablescrollzoom: disablescroll});
  graph.addAnalyser(new AnaTrace());
  var map = loadCarto(clegeoportail, disablescroll, document.getElementById('mapcont'));
  var binfos = false;

  var marker = L.marker([0,0]).addTo(map);
  //var svg = '<svg viewBox="0 0 24 24" height="32" width="32" fill="transparent" stroke="black" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"> <g> <path d="M1 1 l22 22"/> <path d="M1 23 l22 -22"/> </g> </svg>';
  //var iconUrl = 'data:image/svg+xml;base64,' + btoa(svg);
  origIconSize = [32, 32];
  origIconAnchor = [16, 32];
  let iconUrl = 'paraglider.svg';
  //let iconUrl = 'crosshair.svg';
  fetch(iconUrl)
  .then(response => response.text())
  .then((svg) => {
    //let iconUrl = 'data:image/svg+xml;base64,' + btoa(svg);
    //var icon = L.icon({iconUrl: iconUrl, iconSize: origIconSize,iconAnchor: origIconAnchor});
    let icon = L.divIcon({html: svg, className: "",iconSize: origIconSize,iconAnchor: origIconAnchor});
    marker.setIcon(icon);
  })
  .catch(err => {
    console.log(err);
    var icon = L.icon({iconUrl: iconUrl, iconSize: origIconSize,iconAnchor: origIconAnchor});
    marker.setIcon(icon);
  });
  let closegraphcfg = function() {graph.opencfg(true);};
  map.on('click', function(e) {
    setCursorFromMap(e.latlng);
    closegraphcfg();
  });
  map.on('mousemove', function(e) {
    setCursorFromMap(e.latlng);
  });
  map.on('fullscreenchange', function () {
    closegraphcfg();
    if (map.isFullscreen()) {
        graph.disableScrollZoom = false;
    } else {
        graph.disableScrollZoom = disablescroll;
    }
  });
  map.on('movestart', closegraphcfg);
  map.on('zoomstart', closegraphcfg);

  var flstats = {};
  var gpx_bounds = null;
  var touchtimer = null;
  var launchtimer = function(e) {
    touchtimer = window.setTimeout(function(){map.setView(marker.getLatLng());}, 1000);
  };
  document.getElementById('btnClose').addEventListener('click', function(e) {
    e.srcElement.parentElement.style.display = 'none';
  });
  graph.addEventListener('touchstart', launchtimer);
  graph.addEventListener('touchend', function(e) {window.clearTimeout(touchtimer);});
  graph.addEventListener('touchmove', function(e) {window.clearTimeout(touchtimer);launchtimer();});
  graph.addEventListener('ondataloaded', function(e) {
    window.fi = e.detail;
    redrawFlight();
    let s = (fi.pts[fi.pts.length-1].time.getTime() - fi.pts[0].time.getTime()) / 1000;
    let t = new Date(Date.UTC(1970, 0, 1));
    t.setUTCSeconds(s);
    flstats['durée'] = `${dateToTime(t)}`;
    flstats['alt max'] = `${Math.round(fi.maxalt)}m`;
    flstats['alt min'] = `${Math.round(fi.minalt)}m`;
    flstats['vz max'] = `${Math.round(fi.maxvz*10)/10}m/s`;
    flstats['vz min'] = `${Math.round(fi.minvz*10)/10}m/s`;
    let i=0;
    let moyvzpos = fi.pts.reduce((acc, cur) => {if (cur.vz > 0){i++;acc.vz+=cur.vz;} return acc;}, {vz:0}).vz / (i||1);
    flstats['vz+ moy'] = `${Math.round(moyvzpos*10)/10}m/s`;
    flstats['vx max'] = `${Math.round(fi.maxvx)}km/h`;
    flstats['deniv'] = [`${Math.round(fi.pts[0].alt-fi.pts[fi.pts.length-1].alt)}m`, 'dénivelé entre le décollage et l\'atterissage'];
    let totaltgain = Math.round(fi.totaltgain);
    if (totaltgain > 10000) {
      totaltgain = Math.round(fi.totaltgain/100)/10;
      totaltgain = `${totaltgain}km`;
    } else {
      totaltgain = `${totaltgain}m`;
    }
    flstats['tot. gain'] = [totaltgain, 'gain total en altitude'];
      //flstats['vx min'] = `${Math.round(fi.minvx)}km/h`;
    updateTraceInfos();
  });
  graph.addEventListener('onposchanged', function(e) {
    window.curpoint = e.detail;
    let mktxt = e.detail.time.toLocaleString('fr-FR', { /*timeZone: 'UTC'*/ }).substr(-8, 5);
    mktxt+='&nbsp;:&nbsp;'+e.detail.alt+'m';
    mktxt+='<BR>' + e.detail.vz+'m/s&nbsp;&nbsp;&nbsp;'+e.detail.vx+'km/h';
    let curgr = Math.round(Math.min(12, Math.max(1, e.detail.gr)));
    //mktxt+=`<BR><a href="#" onclick="calcStartCone(${e.detail.lat, e.detail.lon, curgr, e.detail.alt})">cone (finesse ${curgr})</a>`;
    marker.bindPopup(mktxt).setLatLng([e.detail.lat, e.detail.lon]).update();
    let vz =  Math.min(maxvz, Math.abs(e.detail.vz));
    let dh = mapelem.offsetHeight/2;
    let hvz = vz * dh / maxvz;
    let r = vz*255/maxvz;
    let g = (maxvz-vz)*255/maxvz;
    if (e.detail.vz > 0) {
      vzelem.style.bottom = (100+dh) + 'px';
      vzelem.style.top = (dh-hvz) + 'px';
      vzelem.setGradient('white',rgbToHex(r,g,0));
    } else {
      vzelem.style.top = dh + 'px';
      vzelem.style.bottom = (100+(dh-hvz)) + 'px';
      vzelem.setGradient(rgbToHex(r,g,0), 'white');
    }
    updateIcon(e.detail);
    /*if (istouch && !map.getBounds().contains(marker.getLatLng())) {
      map.setView(marker.getLatLng());
    }*/
  });
  graph.addEventListener('onclick', function(e) {
    map.setView(new L.LatLng(e.detail.lat, e.detail.lon));
  });
  graph.addEventListener('ondblclick', function(e) {
    let center = marker.getLatLng();
    let zoom = map.getZoom() + 1;
    map.setView(center, zoom);
  });
  graph.addEventListener('onwheel', function(e) {
    let center = marker.getLatLng();
    let zoom = map.getZoom() + (e.detail>0?-1:1);
    map.setView(center, zoom);
  });
  graph.addEventListener('onselectionchanged', function(e) {
    let graphsel = e.detail;
    if (window.selectionline) map.removeLayer(window.selectionline);
    delete flstats.selection;
    updateTraceInfos();

    if (typeof graphsel == 'object' && Array.isArray(window.fi?.pts) && Array.isArray(graphsel) && graphsel.length === 2 && graphsel[1] < fi.pts.length && graphsel[0] != graphsel[1]) {
      let stpt = fi.pts[graphsel[0]],
        endpt = fi.pts[graphsel[1]];
      let portion = fi.pts.slice(graphsel[0], graphsel[1]);
      let prevpt = {lat: stpt.lat, lon: stpt.lon};
      let vxmoy = 0;
      let vzmoy = 0;
      let dist = Math.round(GraphGPX.distance(stpt.lat, stpt.lon, endpt.lat, endpt.lon)/100)/10;
      let totaldist = portion.reduce((total, currentValue, currentIndex, arr) => 
      {
        let tdist = total+GraphGPX.distance(prevpt.lat, prevpt.lon, currentValue.lat, currentValue.lon);
        vxmoy += currentValue.vx;
        vzmoy += currentValue.vz;
        prevpt = currentValue;
        return tdist;
      }, 0);
      vxmoy = Math.round(vxmoy/portion.length);
      vzmoy = Math.round(10*vzmoy/portion.length)/10;
      let deniv = stpt.alt - endpt.alt;
      let finesse = Math.round(100*totaldist / deniv)/100;
      let seconds = (endpt.time.getTime()-stpt.time.getTime())/1000;
      let elapsed = new Date(0);
      elapsed.setSeconds(seconds);
      elapsed = elapsed.toISOString().substring(11, 19);
      let he = parseInt(elapsed.substring(0,2));
      let me = parseInt(elapsed.substring(3,5));
      let se = parseInt(elapsed.substring(6,8));
      elapsed = ((he>0?he+'h':'')+(me>0?me+'\'':'')+(se>0?se+'"':'')).trim();
      totaldist /= 1000;
      deniv *= -1;
      totaldist = Math.round(totaldist*10)/10;
      let vmoy = Math.round((GraphGPX.distance(endpt.lat, endpt.lon, stpt.lat, stpt.lon)/1000)/(seconds/3600));
      if (finesse < 0) {
        finesse = '&infin;';
        deniv = '+' + deniv;
      }
      //<a title="afficher la polaire pour la sélection" href="#" onclick="event.stopPropagation();showpolaire(${JSON.stringify(portion.map(p => ({'vx': p.vx, 'vz': p.vz}))).replaceAll("\"", "'")});">
      let seltext = `<u>Finesse :</u> ${finesse} <i>(${deniv}m en ${totaldist}km à ${vxmoy}km/h, vz moy: ${vzmoy}m/s)<BR><u>Altitude de départ :</u> ${stpt.alt}m<BR><u>Vitesse sur parcours :</u> ${vmoy}km/h en ${elapsed}<BR><u>Distance linéaire :</u> ${dist}km</i>`;
      let selinfos = {'finesse':finesse, 'deniv':deniv, 'distance_totale':totaldist, 'distance_lineaire':dist, 'vxmoy':vxmoy, 'vzmoy':vzmoy, 'altitude_depart':stpt.alt, 'vitesse_parcours':vmoy, 'elapsed':elapsed};
      let csvinfosbtn  = ` <a href="#" onclick="return cpInfosPortion(event, ${JSON.stringify(selinfos).replaceAll("\"", "&quot;")});" title="copier les informations sur la sélection dans le presse-papier">&#x1F4CB;</a>`;
      let csvportionbtn  = ` <a href="#" onclick="return dlPortion(event, ${graphsel[0]}, ${graphsel[1]});" title="télécharger la portion de vol en CSV">&#x1F4BE;</a>`;
      flstats['selection'] = seltext + csvinfosbtn + csvportionbtn;
      updateTraceInfos();
      window.selectionline = L.polyline(portion.map(pt => [pt.lat, pt.lon, pt.alt]),{
          color: '#ff00ff',
          weight: 6,
          opacity: 0.85,
          smoothFactor: 1
        }).bindTooltip(seltext).addTo(map);
    }
  });
  graph.addEventListener('onzoom', function(e) {
    if (e.detail.reset != true) {
      map.fitBounds(L.latLngBounds(L.latLng(e.detail.minlat, e.detail.minlon), L.latLng(e.detail.maxlat, e.detail.maxlon))/*, {padding: [35,35]}*/);
    }
  });

  function fallbackCopyTextToClipboard(text, then, err) {
    var textArea = document.createElement("textarea");
    textArea.value = text;
    
    // Avoid scrolling to bottom
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      var successful = document.execCommand('copy');
      successful ? then() : err();
    } catch (e) {
      err(e);
    }
    document.body.removeChild(textArea);
  }
  function copyTextToClipboard(text, then, err) {
    if (!navigator.clipboard) return fallbackCopyTextToClipboard(text, then, err);
    navigator.clipboard.writeText(text).then(then||(_=>{}), err||(_=>{}));
  }
  
  function cpInfosPortion(event, infos) {
    const csvsep = '\t';
    event.stopPropagation();
    let ks = Object.keys(infos);
    let csv = ks.join(csvsep) + '\n' + ks.map(k => infos[k].toString().replaceAll('.', ',')).join(csvsep);
    copyTextToClipboard(csv, _=>alert('infos copiées en CSV dans le presse papier'), _=>alert('impossible d\'accéder au presse papier'));
  }

  function dlPortion(event, start, end) {
    const csvsep = ';';
    event.stopPropagation();
    let csv = `time${csvsep}alt${csvsep}ground alt${csvsep}lat${csvsep}lon${csvsep}horizontal speed${csvsep}vertical speed${csvsep}bearing\n`;
    let portion = fi.pts.slice(start, end);
    csv += portion.map(pt => {
      return pt.time.toISOString().replace('T',' ').replaceAll('-', '/').slice(0, -1)+csvsep+
        pt.alt+csvsep+
        pt.gndalt+csvsep+
        pt.lat+csvsep+
        pt.lon+csvsep+
        pt.vx+csvsep+
        pt.vz+csvsep+
        pt.bearing;
    }).join('\n');
    let element = document.createElement('a');
    element.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv));
    element.setAttribute('download', 'selection.csv');
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    return false;
  }

  function setCursorFromMap(latlng) {
    if (typeof window.fi === 'undefined' || !Array.isArray(window.fi.pts)) return;
    /*// slice pour éviter de modifier l'ordre du tableau originel
    let nearest = window.fi.pts.slice().sort(function(a, b) {
      let la = L.latLng(a.lat, a.lon);
      let lb = L.latLng(b.lat, b.lon);
      return la.distanceTo(latlng) - lb.distanceTo(latlng);
    })[0];*/
    let nearest = window.fi.pts.reduce(function(a, b) {
      let la = L.latLng(a.lat, a.lon);
      let lb = L.latLng(b.lat, b.lon);
      return la.distanceTo(latlng) > lb.distanceTo(latlng) ? b : a;
    });
    let c1 = map.latLngToLayerPoint(latlng);
    let c2 = map.latLngToLayerPoint(L.latLng(nearest.lat, nearest.lon));
    let dist = Math.sqrt(Math.pow(c2.x-c1.x, 2) + Math.pow(c2.y-c1.y, 2));
    if (dist>100) return;
    window.curpoint = nearest;
    //if (L.latLng(nearest.lat, nearest.lon).distanceTo(latlng)>5000) return;
    let mktxt = nearest.time.toLocaleString('fr-FR', { /*timeZone: 'UTC'*/ }).substr(-8, 5);
    mktxt+='&nbsp;:&nbsp;'+nearest.alt+'m ('+Math.round(nearest.alt-nearest.gndalt)+'m AGL)';
    mktxt+='<BR>' + nearest.vz+'m/s&nbsp;&nbsp;&nbsp;'+nearest.vx+'km/h';
    //let gr = Math.round(Math.min(12, Math.max(1, nearest.gr)));
    //let gr = 8;
    //mktxt+=`<BR><a href="#" onclick="calcStartCone(${nearest.lat}, ${nearest.lon}, ${gr}, ${nearest.alt})">cone (finesse ${gr})</a>`;
    marker.bindPopup(mktxt).setLatLng([nearest.lat, nearest.lon]).update();
    graph.setPos(nearest);
    updateIcon(nearest);
  }

  function updateIcon(pt) {
    if (typeof window.fi === 'undefined' || !Array.isArray(window.fi.pts)) return;
    let dispmode = window.dispmode ?? 'alt';
    let iconText = '';
    switch (dispmode) {
      case 'vz':
        iconText = pt.vz + ' m/s';
        break;
      case 'vx':
        iconText = pt.vx + ' km/h';
        break;
      case 'GR':
        iconText = pt.gr;
        break;
      case 'altsol':
        iconText = (pt.alt - pt.gndalt) + ' m';
        break;
      case 'alt':
      default:
        iconText = parseInt(pt.alt) + ' m';
        break;
    }
    let ratio = 0.5*(pt.alt-window.fi.minalt)/(window.fi.maxalt-window.fi.minalt);
    //ratio += 0.75; // ratio est contenu dans [0.75, 1.75]
    ratio += 1.3; // ratio est contenu dans [1.3, 1.8]
    let icon = marker.options.icon;
    icon.options.iconSize = origIconSize.map(s => s * ratio);
    icon.options.iconAnchor = origIconAnchor.map((s,i) => s/origIconSize[i] * icon.options.iconSize[i]);
    marker.setIcon(icon);
    //marker.setRotationOrigin("center");
    marker.setRotationOrigin(icon.options.iconAnchor.map(v => v+"px").join(' '));
    marker.setRotationAngle(pt.bearing+180);
    let iconelem = document.getElementById('icon-paraglider-text');
    if (iconelem) iconelem.textContent = iconText;
  }

  function redrawFlight() {
    window.dispmode = typeof window.dispmode === 'string'?window.dispmode:'vz';
    if (dispmode == 'alt') {
      hotlineLayer.setLatLngs(window.fi.pts.map(pt => ([pt.lat, pt.lon, pt.alt])));
      hotlineLayer.setStyle({'min':fi.minalt, 'max':fi.maxalt});
    } else if (dispmode == 'vz') {
      hotlineLayer.setLatLngs(window.fi.pts.map(pt => ([pt.lat, pt.lon, pt.vz])));
      hotlineLayer.setStyle({'min':-3/*fi.minvz*/, 'max':5/*fi.maxvz*/});
    } else if (dispmode == 'vx') {
      hotlineLayer.setLatLngs(window.fi.pts.map(pt => ([pt.lat, pt.lon, pt.vx])));
      hotlineLayer.setStyle({'min':0/*fi.minvx*/, 'max':fi.maxvx/*55*/});
    } else if (dispmode == 'GR') {
      hotlineLayer.setLatLngs(window.fi.pts.map(pt => ([pt.lat, pt.lon, pt.gr])));
      hotlineLayer.setStyle({'min':0/*fi.minvx*/, 'max':40/*55*/});
    } else if (dispmode == 'altsol') {
      let pts = window.fi.pts.map(pt => ([pt.lat, pt.lon, pt.alt - pt.gndalt]));
      let ptsr = pts.map(p => p[2]);
      let min = Number.MAX_SAFE_INTEGER;
      let max = Number.MIN_SAFE_INTEGER;
      ptsr.forEach(p => {if (p<min) min = p;if (p>max) max = p;})
      hotlineLayer.setLatLngs(pts);
      hotlineLayer.setStyle({'min':min, 'max':max});
    } else {
      hotlineLayer.setLatLngs(window.fi.pts.map(pt => ([pt.lat, pt.lon, 0])));
      hotlineLayer.setStyle({'min':0, 'max':0.1});
    }
    /*hotlineLayer.setStyle({
      'palette': {
        0.0: '#0000ff',
        0.4: '#00ff00',
        0.7: '#ffff00',
        1.0: '#ff0000'
      }
    });*/
    hotlineLayer.redraw();
  }
  function redrawAltData(dmalt) {
    window.dispmodealt = typeof window.dispmodealt === 'string'?window.dispmodealt:'baro';
    if (dmalt === dispmodealt) return;
    else dispmodealt = dmalt ?? 'gps';
    if (dispmodealt == 'baro') {
      points = points.map(pt => {pt.alt=pt.altbaro;return pt})
    } else {
      points = points.map(pt => {pt.alt=pt.altgps;return pt})
    }
    let pointshotline = points.map(pt => [pt.lat, pt.lon, pt.alt]);
    if (window.hotlineLayer) hotlineLayer.remove(map);
    window.hotlineLayer = L.hotline(pointshotline, {
      min: -5,//Math.min.apply(null, pointshotline.map(pt => pt[2])),
      max: 8,//Math.max.apply(null, pointshotline.map(pt => pt[2])),
      'palette': {
        0.0: '#0000ff',
        0.4: '#00ff00',
        0.7: '#ffff00',
        1.0: '#ff0000'
      },
      weight: 2,
      outlineColor: '#000000',
      outlineWidth: 0.5
    });
    graph.setData(points);
    hotlineLayer.addTo(map);
  }
  function updateTraceInfos() {
    let divTraceInfos = document.getElementById('divTraceInfos');
    let date = "?";
    if (typeof fi == 'object' && Array.isArray(fi.pts) && fi.pts.length > 0) {
      date = fi.pts[0].time;
      date = ('0'+date.getDate()).slice(-2)+"/"+('0'+(date.getMonth()+1)).slice(-2)+"/"+date.getFullYear();
    }
    let dname = typeof window.pilotname === 'string' && window.pilotname.trim().length > 0 ? '<BR>'+window.pilotname:'';
    let htmlinfos = '<div id="ctinfos"><p class="gras centre souligne">'+date+dname+'</p>';
    for (let prop in flstats) {
      let propval = flstats[prop];
      htmlinfos += "<p";
      if (Array.isArray(propval) && propval.length > 1) {
        htmlinfos += " title=\""+propval[1]+"\"";
        propval = propval[0];
      }
      htmlinfos += ">";
      if (flstats[prop].length == 0) {
        htmlinfos += "<HR>";
      } else {
        htmlinfos += "<span class=\"gras\">"+prop+"</span>&nbsp;:&nbsp;"+propval;
      }
      htmlinfos += "</p>";
    }
    htmlinfos += '</div><p id="iinfos">&#9432;</p>';
    divTraceInfos.innerHTML = htmlinfos;
    divTraceInfos.style.display = 'block';
    divTraceInfos.onclick = updateInfoVisibility;
    updateInfoVisibility(true);
  }
  function updateInfoVisibility(notoggle) {
    if (notoggle !== true) binfos = !binfos;
    document.getElementById('ctinfos').style.display = binfos ? 'none':'block';
    document.getElementById('iinfos').style.display = !binfos ? 'none':'block';
  }
  function parseIRecord(line) {
    const extensions = {};
    line = line??'';
    const IRE = /I(\d\d)(\d{4}.{3})+/;
    const EXTRE = /(\d{2})(\d{2})(.{3})/;
    if (IRE.test(line)) {
      let matches = line.match(IRE);
      let nbr = parseInt(matches[1]);
      line = line.substring(3);
      for (let i = 0; i < nbr; i++) {
        matches = line.match(EXTRE);
        if (matches == null || matches.length != 4) continue;
        extensions[matches[3]] = {'start': parseInt(matches[1])-1, 'end': parseInt(matches[2])};
        line = line.substring(i+7);
      }
    }
    return extensions;
  }
  function parseBRecord(r) {
    //0000000000111111111122222222223333333
    //0123456789012345678901234567890123456
    //B0925064454728N00535480EA016100161528
    let date = new Date(startdate);
    date.setHours(parseInt(r.substr(1,2)));
    date.setMinutes(parseInt(r.substr(3,2)));
    date.setSeconds(parseInt(r.substr(5,2))+tzoffset);
    let altbaro = parseInt(r.substr(25,5));
    let altgps = parseInt(r.substr(30,5));
    //if (alt == 0) alt = altgps;
    let lat = parseFloat(r.substr(7,2));
    let mmmext = 0;
    if (extensions.hasOwnProperty('LAD')) {
      mmmext = parseInt(r.substring(extensions['LAD'].start, extensions['LAD'].end));
    }
    lat += parseFloat((r.substr(9,2)+'.'+r.substr(11,3)+mmmext))/60;
    lat *=  r[14]=='N'?1:-1;
    let lon = parseFloat(r.substr(15,3));
    mmmext = 0;
    if (extensions.hasOwnProperty('LOD')) {
      mmmext = parseInt(r.substring(extensions['LOD'].start, extensions['LOD'].end));
    }
    lon += parseFloat((r.substr(18,2)+'.'+r.substr(20,3)+mmmext))/60;
    lon *=  r[23]=='E'?1:-1;
    return {
      lat: lat,
      lon: lon,
      time: date,
      /*alt: {
        baro: parseInt(r.substr(25,5)),
        gps: parseInt(r.substr(30,5))
      },*/
      alt: window.dispmodealt!='baro'?altgps:altbaro,
      altbaro: altbaro,
      altgps: altgps
    };
  }
  async function loadIGC(igccont, calcfs) {
    if (typeof igccont !== 'string') {
      igccont = document.getElementById('igccont').value;
      document.getElementById('formcont').style.display = 'none';
    }
    if (calcfs === true) calcFlightScore(igccont);
    let lines = igccont.split(/\r?\n/);
    window.extensions = parseIRecord(lines.find(l => l.trim().startsWith('I')));
    let records = lines.filter(l => l.trim().startsWith('B'));
    window.pilotname = lines.find(l => l.trim().startsWith('HFPLTPILOTINCHARGE'))?.split(':')[1];
    //0000000000111111111
    //0123456789012345678
    //HFDTEDATE:100522,01
    window.startdate = new Date();
    lines.filter(l => l.trim().startsWith('HFDTEDATE')).forEach(startdateline => {
      let tmpstartdate = new Date();
      if (startdateline) {
        tmpstartdate.setDate(parseInt(startdateline.substr(10,2)));
        tmpstartdate.setMonth(parseInt(startdateline.substr(12,2))-1);
        let year = 2000+parseInt(startdateline.substr(14,2));
        if (year > tmpstartdate.getFullYear()) year -= 100;
        tmpstartdate.setFullYear(year);
      }
      if (tmpstartdate < startdate) startdate = tmpstartdate;
    });
    if (typeof tzoffset !== 'number' || tzoffset < 0) {
      window.tzoffset = 0;
      if (records.length > 0) {
        // si le décalage horaire n'a pas été fourni on essaie de le deviner à partir de la date de décollage
        if (typeof launchtime?.getMonth === 'function') {
          let fpt = parseBRecord(records[0]);
          tzoffset = (launchtime.getTime()-fpt.time.getTime())/1000;
        } else if (cletimezonedb.length > 0) { // sinon on essaie de le trouver via l'api timezonedb
          let p = parseBRecord(records[0]);
          let url = `https://api.timezonedb.com/v2.1/get-time-zone?key=${cletimezonedb}&format=json&by=position&lat=${p.lat}&lng=${p.lon}&time=${Math.trunc(p.time.getTime()/1000)}`;
          let data = await fetch(url).then(response => response.json()).catch(err => {});
          //.then(response => response.text())
          //.then(str => new window.DOMParser().parseFromString(str, "text/xml"))
          tzoffset = data && typeof data.gmtOffset === 'number' ? data.gmtOffset : 0;
          //tzoffset = parseInt(data.getElementsByTagName("gmtOffset")[0].textContent);
        }
      }
    }

    window.points = [];
    records.forEach(r => {
      points.push(parseBRecord(r));
    });
    if (!points.some(p => p.altbaro != 0)) {
      points = points.map(pt => {pt.alt=pt.altbaro=pt.altgps;return pt})
    }
    points.sort((a, b) => a.time-b.time);
    let interval = Math.ceil((points[points.length - 1].time.getTime() - points[0].time.getTime())/points.length);
    interval = Math.round(interval/1000)*1000;
    let gap = 0;
    let j = 0, k = 0;
    let clone = null;
    for (let i=1; i<points.length; i++) {
      gap = points[i].time.getTime() - points[i-1].time.getTime();
      if (gap > interval) {
        //let url = location.protocol+'//'+location.hostname+(location.port?":"+location.port:"")+location.pathname+(location.search?location.search:"");
        //\n${url}#${points[i].time.getTime()}
        console.log(`trou dans la trace de ${gap}ms @${points[i].time.toString()}`);
        j = i+gap/interval;
        k = i-1;
        for (; i<j; i++) {
          clone = JSON.parse(JSON.stringify(points[i-1]));
          clone.time = new Date(new Date(clone.time).getTime() + interval);
          points.splice(i, 0, clone);
        }
      }
    }
    redrawAltData();
    window.gpx_bounds = hotlineLayer.getBounds();
    map.fitBounds(gpx_bounds/*, {padding: [35,35]}*/);

    let btndl = document.getElementById('btnDlTrace');
    btndl.onclick = function() {downloadIGC(igccont, startdate);/*window.location = "data:application/octet-stream,"+encodeURI(igccont);*/};
    btndl.style.display = 'block';
    let btnkmz = document.getElementById('btnDlKMZ');
    btnkmz.onclick = function() {downloadKMZ(igccont, startdate);};
    btnkmz.style.display = 'block';
    let divDispMode = document.getElementById('divDispMode');
    divDispMode.appendChild(document.getElementById('dispmodes'))
    divDispMode.style.display = 'block';
    let btnCalcCone = document.getElementById('btnCalcCone');
    btnCalcCone.onclick = async function() {
      if (window.conecalculating) {
        window.conecalculating = false;
        imgConeLoading.style.display='none';
        if (window.conecontroller) {
          conecontroller.abort();
        }
      } else {
        if (window.curpoint) {
          window.conecalculating=true;
          imgConeLoading.style.display='block';
          await calcStartCone(curpoint.lat, curpoint.lon, 8, curpoint.alt);
          window.conecalculating=false;
          imgConeLoading.style.display='none';
        }
      }
    };
    btnCalcCone.style.display = 'block';
  }
  function downloadIGC(igccont, startdate) {
    const a = document.createElement("a");
    a.setAttribute('href', "data:application/octet-stream,"+encodeURI(igccont));
    if (typeof startdate.toISOString === 'function') {
      a.setAttribute('download', startdate.toISOString().substring(0,10)+".igc");
    } else {
      a.setAttribute('download', "track.igc");
    }
    const textnode = document.createTextNode("télécharger");
    a.appendChild(textnode);
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
  }
  function downloadKMZ(igccont, startdate) {
    let filename = "track.kmz";
    if (typeof startdate.toISOString === 'function') {
      filename = startdate.toISOString().substring(0,10)+".kmz";
    }
    igc2kmz(igccont, filename).catch(err => {
      alert(err);
      throw err;
    });
  }
  function getIGC(igc) {
    let xhttp = new XMLHttpRequest();
    xhttp.responseType = 'text';
    xhttp.onreadystatechange = function() {
      if (this.readyState == 4 && this.status == 200) {
        if (!this.responseText) return;
        window.igccontent = this.response;
        document.getElementById('formcont').style.display = 'none';
        loadIGC(this.response, typeof finfo !== 'string');
        document.getElementById('igccont').value = this.response;
        chargement(false);
      }
    };
    xhttp.open("GET", igc, true);
    xhttp.send(null);
  }
  function displayFlightScore(flightscore) {
    let isTriangle = function() { return (flightscore.opt.scoring.code == 'tri' || flightscore.opt.scoring.code == 'fai'); };
    flstats['flightscore'] = '';
    if (typeof flightscore.scoreInfo == 'object') {
      flstats['distance'] = `${Math.round(flightscore.scoreInfo.distance*100)/100}km`;
      flstats['type'] = `${flightscore.opt.scoring.name}`;
      if (Array.isArray(flightscore.scoreInfo.tp)) {
        scorepointlist = [];
        let tps = flightscore.scoreInfo.tp;
        if (flightscore.scoreInfo.cp) {
          let tmpmarker = L.marker([flightscore.scoreInfo.cp.in.y, flightscore.scoreInfo.cp.in.x], {icon: startIcon});
          tmpmarker.addTo(map).bindPopup("start");
          if (!isTriangle()) {
            scorepointlist.push(tmpmarker);
          }
        } else if (flightscore.scoreInfo.ep) {
          let tmpmarker = L.marker([flightscore.scoreInfo.ep.start.y, flightscore.scoreInfo.ep.start.x], {icon: startIcon});
          tmpmarker.addTo(map).bindPopup("start");
          if (!isTriangle()) {
            scorepointlist.push(tmpmarker);
          }
        }
        for (let i=0; i<tps.length; i++) {
          let markertp = L.marker([tps[i].y, tps[i].x], {icon: turnpointIcon});
          markertp.addTo(map).bindPopup("TP#"+(i+1));
          scorepointlist.push(markertp);
        }
        if (isTriangle()) {
          scorepointlist.push(scorepointlist[scorepointlist.length-tps.length]);
        }
        if (flightscore.scoreInfo.cp) {
          let tmpmarker = L.marker([flightscore.scoreInfo.cp.out.y, flightscore.scoreInfo.cp.out.x], {icon: finishIcon});
          tmpmarker.addTo(map).bindPopup("finish");
          if (!isTriangle()) {
            scorepointlist.push(tmpmarker);
          }
        } else if (flightscore.scoreInfo.ep) {
          let tmpmarker = L.marker([flightscore.scoreInfo.ep.finish.y, flightscore.scoreInfo.ep.finish.x], {icon: finishIcon});
          tmpmarker.addTo(map).bindPopup("finish");
          if (!isTriangle()) {
            scorepointlist.push(tmpmarker);
          }
        }
        scorelinepath = new L.Polyline(scorepointlist.map(pt => pt.getLatLng()), {
          color: 'red',
          weight: 2,
          opacity: 0.5,
          smoothFactor: 1
        }).addTo(map);
      }
    }
    flstats['score'] = `${Math.round(flightscore.score*10)/10}pts`;
    flstats['vit.'] = `${Math.round(36000*flightscore.scoreInfo.distance/(flightscore.opt.landing-flightscore.opt.launch))/10}km/h`;
    updateTraceInfos();
  }
  function calcFlightScore(igccontent) {
    if (typeof igccontent !== 'string') return;
    try {
      IGCScore.score(igccontent, (score) => {
        if (score && typeof score.value == 'object') {
          score = score.value;
        }
        if (score && typeof score.opt == 'object' && typeof score.opt.flight == 'object') delete score.opt.flight;
        displayFlightScore(score);
      });
    } catch(e) {console.log(e);}
  }
  function loadFlightScore(finfo) {
    let xhttp = new XMLHttpRequest();
    xhttp.responseType = 'json';
    xhttp.onreadystatechange = function() {
      if (this.readyState == 4) {
        if (this.status == 200) {
          try {
            if (typeof this.response == 'object') {
              displayFlightScore(this.response);
            }
          } catch(e) {window.finfo=null;calcFlightScore(window.igccontent);}
        } else {
          window.finfo=null;
          calcFlightScore(window.igccontent);
        }
      }
    };
    xhttp.open("GET", finfo, true);
    xhttp.send();
  }
  function showpolaire(portion) {
    portion.sort((p1, p2) => p1.vx - p2.vx);
    var trace1 = {
      x: portion.map(p => p.vx),
      y: portion.map(p => p.vz),
      mode: 'lines+markers'
    };
    Plotly.newPlot('graphPolaire', [ trace1 ], { title:'Polaire des vitesses pour la zone sélectionnée'});
    document.getElementById('popupPolaire').style.display='block';
  }
  function dateToTime(dt) {
    let time = dt.toLocaleString('fr-FR', { timeZone: 'UTC' }).substr(-8, 8);
    let hours = parseInt(time.substring(0,2));
    let minutes = parseInt(time.substring(3,5));
    let seconds = parseInt(time.substring(6,8));
    time = '';
    if (hours != 0) time += hours + 'h';
    if (minutes >= 5 || (minutes > 0 && hours == 0)) time += minutes + 'm'; // si vol > 1h => pas de minutes en dessous de 5
    if (hours == 0 && seconds != 0) time += seconds + 's';
    return time;
  }
  function zeroPad(num, places) {
    return String(num).padStart(places, '0');
  }
  function chargement(load=true) {
    loading.style.display = load?'block':'none';
  }
  window.onload = function() {
    if (igc) {
      chargement();
      getIGC(igc);
      document.getElementById('formcont').style.display = 'none';
      if (finfo)
        loadFlightScore(finfo);
    } else {
      chargement(false);
      document.getElementById('formcont').style.display = 'block';
    }
    document.getElementById('frmsub').style.display = 'block';
  };

  window.onresize = function(e) {
    if (map && gpx_bounds && !usermoved)
      map.fitBounds(gpx_bounds/*, {padding: [35,35]}*/);
  };
  window.onhashchange = function(e) {
    let hash = location.hash.substring(12).trim();
    let timetoseek = parseInt(hash);
    if (/^\d+$/g.test(hash) && Array.isArray(points) && points[0].time.getTime() <= timetoseek && points[points.length-1].time.getTime() >= timetoseek) {
      console.log(points.find(p => p.time.getTime() == timetoseek));
    }
  };

  async function calcStartCone(lat, lon, finesse, amsl) {
    try {
      if (window.conecontroller) {
        conecontroller.abort();
      }
      window.conecontroller = new AbortController();
      let conesignal = conecontroller.signal;
      if (window.startconept) {
        map.removeLayer(startconept);
        startconept = null;
      }
      tiles?.forEach(z => {
        if (z.marker) map.removeLayer(z.marker);
      });
      tilepaths?.forEach(z => {
        map.removeLayer(z);
      });
      tiles=[];
      tilepaths=[];
      window.startconept = L.marker([lat, lon], {draggable:'false'}).addTo(map);
      let now = Date.now();
      window.curfinessecalc = now;
      const response = await fetch(`elevation/getConeFinesse.php?lat=${lat}&lon=${lon}&finesse=${finesse}&amsl=${amsl}`, {signal: conesignal});
      const res = await response.json();
      if (now == window.curfinessecalc) {
        console.log(res);
        squareside = res.squareside;
        dx = res.dx;
        dy = res.dy;
        ddx = dx/2;
        ddy = dy/2;
        res.tiles.forEach(drawTile);
      } else {
        console.log('outdated calc :', res);
      }
    } catch (err) {
      console.error(err);
    }
  }
  function color(val, max=300, min=0) {
    val = Math.max(min, Math.min(val, max));
    let moy = min + (max-min) / 2;
    let r = val<moy?0xff:Math.round(((moy-(val-moy))*0xff/moy));
    let g = val>moy?0xff:Math.round((val*0xff/moy));
    /*max-=min;
    val-=min;
    let a = 0.1*(max-val)/max;
    a+=0.4;*/
    let a = tileopacity;
    let clr = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}00`;
    return {color: clr, fillColor: clr, fillOpacity: a};
  }
  function drawTile(tile) {
    if (tile.alt <= 0 && (tile.x!=0 || tile.y!=0)) return;
    let latlngs = [
      [tile.pos.lat-ddy,tile.pos.lng-ddx],
      [tile.pos.lat+ddy,tile.pos.lng-ddx],
      [tile.pos.lat+ddy,tile.pos.lng+ddx],
      [tile.pos.lat-ddy,tile.pos.lng+ddx]
    ];
    //https://leafletjs.com/reference.html#path
    let alt = tile.alt<1?Math.round(tile.alt*10)/10:Math.round(tile.alt);
    let tttext = `${alt}m AGL`;
    let polygon = L.polygon(latlngs, {opacity:tileopacity, fillOpacity:tileopacity}).bindTooltip(tttext).addTo(map);
    clroptions = color(tile.alt);
    tile.marker=polygon;
    polygon.setStyle({weight:1, lineJoin:'bevel', ...clroptions});
    //polygon.on('mouseover',() => drawPath(tile));
    polygon.on('mouseover', function () {
        drawPath(tile);
      });
    //polygon.on('mouseout', clearPaths);
      tiles.push(tile);
    }
  function clearPaths(origtile) {
    // bug de tooltips qui restent ouverts si on déplace la carte en même temps
    tiles.forEach(tile => {
      if (tile == origtile) return;
      tile.marker.closeTooltip();
    });
      tilepaths?.forEach(z => {
        map.removeLayer(z);
      });
    tilepaths=[];
  }
  function drawPath(tile) {
    clearPaths(tile);
    let pathcoord = [];
    let origtile = tile;
    do {
      pathcoord.push([tile.pos.lat, tile.pos.lng]);
      //tilepaths.push(L.marker([tile.pos.lat, tile.pos.lng], {draggable:'true'}).addTo(map));
      tile = tile.parent?tileAt(tile.parent.x, tile.parent.y):null;
    } while (tile);
    let d = pathcoord.reduce((acc, cur, i) => {return (i>0)?acc+GraphGPX.distance(pathcoord[i-1][0], pathcoord[i-1][1], cur[0], cur[1]):0;}, 0);
    let tttext = `${formatAlt(origtile.alt)}m AGL (${formatAlt(origtile.alt+origtile.altgnd)}m), ${formatDistance(d)}`;
    origtile.marker.setTooltipContent(tttext);
    tilepaths.push(new L.Polyline(pathcoord, {
      color: 'black',
      weight: 3,
      opacity: 1,
      smoothFactor: 1
    })/*.bindTooltip(tttext)*/.addTo(map));
    tilepaths.push(new L.circle([origtile.pos.lat, origtile.pos.lng], {color: 'black', fillOpacity: 1, radius: 0.1*squareside}).bindTooltip(tttext).addTo(map));
  }
  function tileAt(x, y) {
    return tiles.find(t => t.x == x && t.y == y);
  }
  function formatAlt(alt) {
    return alt<1?Math.round(alt*10)/10:Math.round(alt);
  }
  function formatDistance(d) {
    let unit='m';
    if (d>=1000) {
      d /= 1000;
      unit='km';
    }
    if (d<100) {
      d = Math.round(d*10)/10;
    } else {
      d = Math.round(d);
    }
    return d+unit;
  }
</script>
</body>
</html>
